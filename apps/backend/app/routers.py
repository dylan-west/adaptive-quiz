from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import text
from typing import List, Optional
from .db import get_session
from .embedder import embed_texts
import os

router = APIRouter()

@router.get("/healthz")
def healthz(db: Session = Depends(get_session)):
    db.execute(text("SELECT 1"))
    return {"ok": True}

@router.post("/dev/seed")
def seed_demo(db: Session = Depends(get_session)):
    """
    Dev helper: insert a tiny doc with 3 chunks + embeddings so you can test vector search.
    Safe to call multiple times; it won't duplicate.
    """
    # Create a user and document (id generated by DB)
    user_row = db.execute(text("SELECT id FROM users LIMIT 1")).fetchone()
    if not user_row:
        user_row = db.execute(text("INSERT INTO users(email) VALUES(:e) RETURNING id"), {"e": "demo@example.com"}).fetchone()
    user_id = user_row[0]

    doc_row = db.execute(text("SELECT id FROM documents WHERE title = :t"), {"t": "Demo Doc"}).fetchone()
    if not doc_row:
        doc_row = db.execute(text("""
            INSERT INTO documents(owner_id, title, meta)
            VALUES (:owner, :title, '{}'::jsonb)
            RETURNING id
        """), {"owner": user_id, "title": "Demo Doc"}).fetchone()
    doc_id = doc_row[0]

    samples = [
        ("Puppy training basics include positive reinforcement and short sessions.", 1, 1, ["Training"]),
        ("NVIDIA driver troubleshooting on Windows often involves clean installs and DDU.", 2, 2, ["GPUs"]),
        ("Tomatoes grow well in containers with 6+ hours of sun and regular watering.", 3, 3, ["Gardening"]),
    ]

    # Insert chunks if missing
    chunk_ids = []
    for txt, ps, pe, tags in samples:
        exists = db.execute(text("SELECT id FROM chunks WHERE doc_id=:d AND text=:t"), {"d": doc_id, "t": txt}).fetchone()
        if exists:
            chunk_ids.append(exists[0])
            continue
        row = db.execute(text("""
            INSERT INTO chunks(doc_id, text, page_start, page_end, headings, concept_tags)
            VALUES (:doc_id, :text, :ps, :pe, :hd, :tags)
            RETURNING id
        """), {"doc_id": doc_id, "text": txt, "ps": ps, "pe": pe, "hd": ["Demo"], "tags": tags}).fetchone()
        chunk_ids.append(row[0])

    # Make embeddings for any chunks missing them
    texts_to_embed = []
    ids_to_embed = []
    for cid, (txt, *_rest) in zip(chunk_ids, samples):
        has = db.execute(text("SELECT 1 FROM embeddings WHERE chunk_id=:cid"), {"cid": cid}).fetchone()
        if not has:
            texts_to_embed.append(txt)
            ids_to_embed.append(cid)

    if ids_to_embed:
        vecs = embed_texts(texts_to_embed)
        # build '[v1,v2,...]' literal for pgvector
        for cid, vec in zip(ids_to_embed, vecs):
            qvec = "[" + ",".join(f"{x:.6f}" for x in vec) + "]"
            db.execute(text("""
                INSERT INTO embeddings(chunk_id, embedding, model_name)
                VALUES (:cid, (:qvec)::vector, :model)
            """), {"cid": cid, "qvec": qvec, "model": os.getenv("OPENAI_EMBEDDING_MODEL","dev-fake")})

    return {"seeded_chunks": [str(c) for c in chunk_ids], "provider": os.getenv("EMBEDDING_PROVIDER","openai")}

@router.get("/search")
def search(
    q: str = Query(..., description="Query string"),
    k: int = Query(5, ge=1, le=20),
    db: Session = Depends(get_session),
):
    """
    Vector search if possible; falls back to ILIKE if embedding/provider is unavailable.
    """
    try:
        vec = embed_texts([q])[0]
        qvec = "[" + ",".join(f"{x:.6f}" for x in vec) + "]"
        rows = db.execute(text("""
            SELECT c.id::text,
                   c.text,
                   1 - (e.embedding <=> (:qvec)::vector) AS cosine_similarity,
                   c.page_start, c.page_end
            FROM embeddings e
            JOIN chunks c ON c.id = e.chunk_id
            ORDER BY e.embedding <=> (:qvec)::vector
            LIMIT :k
        """), {"qvec": qvec, "k": k}).mappings().all()
        return {"mode": "vector", "query": q, "count": len(rows), "results": list(rows)}
    except Exception as e:
        # Fallback: simple text match
        rows = db.execute(text("""
            SELECT id::text, text, page_start, page_end
            FROM chunks
            WHERE text ILIKE '%' || :q || '%'
            ORDER BY created_at DESC
            LIMIT :k
        """), {"q": q, "k": k}).mappings().all()
        return {"mode": "text", "query": q, "count": len(rows), "results": list(rows), "error": str(e)}

# --- Quiz stubs (unchanged) ---
@router.post("/quiz/start")
def quiz_start(user_id: Optional[str] = None):
    return {"status": "ok", "message": "quiz session created (stub)", "session_id": "demo"}

@router.post("/quiz/answer")
def quiz_answer(session_id: str, item_id: str, choice: int):
    return {"status": "ok", "message": "answer recorded (stub)", "correct": False, "next_item": None}
